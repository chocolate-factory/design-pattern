# Chapter1

## 디자인 패턴이란

- 소프트웨어 설계에서 얻은 세세한 경험들을 기록해 놓도록 하는 것 → 올바른 설계를 빨리 만들 수 있도록 도와준다.(p.26)
- 특정한 전후 관계에서 일반적 설계 문제를 해결하기 위해 상호 교류하는 수정 가능한 객체와 클래스 들에 대한 설명 (p.29)

## 디자인 패턴을 이용하여 문제를 푸는 방법

- 객체 (object)
    - 데이터와 데이터에 연산을 가하는 procedure를 함께 묶은 단위
    - 요청은 객체가 연산을 실행하게 하는 유일한 방법이고 연산은 객체의 내부 데이터의 상태를 변경하는 유일한 방법. (encapsulate)
- 객체 지향 설계는 현실과 대응 관계를 갖지 못할 때가 많음 (적당한 객체 찾기 혹은 객체의 적당한 분할)
    - 설계 단계 동안 만들어야 하는 새로운 추상화는 "설계의 유연성"을 증진시켜야 한다.
    - 디자인 패턴은 덜 명확한 추상적 개념과 객체를 알아보는데에 도움을 준다.
- 객체의 크기 결정
    - facade, flyweight, builder 등 다양한 방식으로 객체를 생성, 분할 하는 방법을 다룬다
- 객체 인터페이스의 명세
    - 용어
        - Signature
            - 객체가 선언하는 이름, 매개 변수로 받아들이는 객체들, 연산의 반환값을 명세 한것
        - Interface
            - 객체가 정의하는 모든 signatrue, 객체가 받아서 처리 할 수있는 연산의 집합
        - Type
            - 특정 interface를 나타낼 때 사용하는 말
            - 객체가 `Windows` type을 갖는 다는 것은 `Windows` 인터페이스에 정의한 모든 연산들을 처리 할 수 있다는 의미
        - 다른 interface를 포함하는 interface를 subtype(자식), 다른 interface가 포함하는 interface를 supertype(부모) 이라고 합니다. subtype은 supertype의 인터페이스를 상속 한다고 합니다.
        - 동적 바인딩(dynamic binding)
            - 어떤 요청과 요청을 처리할 객체를 runtime에 연결 짓는 것
            - 객체를 동일한 인터페이스를 갖는 다른 객체로 대체 할 수 있게 해줌, 이런 대체성을 다형성 이라고 함.
    - 디자인 패턴은 인터페이스에 정의해야 하는 중요한 요소가 무엇이고 어떤 종류의 데이터를 주고 받아야 하는지 식별하여 인터페이스를 정의하도록 도와준다(p.43)
    - 디자인 패턴은 인터페이스 간의 관련성도 정의한다.
- 객체 구현 명세하기
    - 추상 클래스
        - 모든 서브 클래스 사이의 공통되는 인터페이스를 정의합니다.
    - 믹스인 클래스
        - 다른 클래스들에게 선택적인 인터페이스 혹은 기능을 제공하려는 목적을 가진 클래스
        - 다중 상속이 필요함.
- 클래스 와 타입
    - 클래스:  객체의 내부 상태와 그 객체의 연산에 대한 구현방법
    - 타입: 객체의 인터페이스, 객체가 응답 할 수 있는 요청의 집합
- 클래스 상속 과 인터페이스 상속
    - 클래스 상속- 코드와 내부 표현 구조를 공유하는 메커니즘
    - 인터페이스 상속 - 어떤 객체가 다른 객체 대신에 사용 될 수있는 경우를 지정하는 메커니즘
- **구현에 따르지 않고 인터페이스에 따르는 프로그래밍**
    - 사용자가 원하는 인터페이스를 그 객체가 만족하고 있는 한, 사용자는 그들이 사용하는 특정 객체 타입에 대해 알아야 할 필요는 없습니다.
    - 사용자는 이 객체들을 구현하는 클래스를 알 필요가 없고 단지 인터페이스를 정의 하는 추상 클래스가 무엇인지만 알면 됩니다.
    - 어던 변수를 구체 클래스의 인스턴스로 선언하는것을 피합시다. 추상 클래스의 인터페이스를 다르는 인스턴스 변수를 선언하여 사용합시다.

## 재사용을 실현 가능한 것으로

- 상속의 단점
    - 런타임에 상속받은 부모 클래스의 구현을 변경 할 수는 없다.
    - 부모 클래스의 구현이 서브 클래스에 다 드러나는 것이기 때문에 상속은 캡슐화를 파괴한다는 주장도 있음.
    - 서브 클래스는 부모 클래스의 구현에 종속된다. → 부모 클래스가 바뀌면 서브 클래스도 변경 해야한다.
- 객체 합성(composition)
    - 한 객체가 다른 객체에 대한 참조자를 얻는 방식, 런타임에 정의된다.
    - 객체가 다른 객체의 인터페이스만을 바라보게 한다.
    - 객체는 인터페이스에 맞추어 구현되므로 구현 사이의 종속성은 줄어든다.
    - 각 클래스 별로 캡슐화를 유지 할 수 있고 각 클래스의 한가지 작업에만 집중할 수 있다.
- 위임(deligation)
    - 두 객체가 하나의 요청을 처리한다.
    - 수신객체가 연산의 처리를 위임자에게 보냅니다.
    - 런타임에 행동의 복합을 가능하게 하고, 복합 하는 방식도 변경 해준다.
    - 이해하기 어렵다. 클래승의 상호작용이 정의 되어있는것이 아닌 런타임 객채에 따라서 그 결과가 다르기 때문.

## 패턴 용어

- Facade - 서브시스템에 있는 인터페이스 집합에 대해서 하나의 통합된 인터페이스를 제공하는 패턴
- Flyweight - 크기가 작은 여러 객체가 여러 개 있을 때, 공유를 통해 이들을 효율적으로 지원하는 패턴