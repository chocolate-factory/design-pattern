# Chapter3. Creational Pattern

## Creational Pattern

- 인스턴스를 만드는 절차를 추상화하는 패턴.
- 무엇이 생성되고, 누가 생성하고, 어떻게 생성 되는지, 언제 생성 할 것인지 결정하는데에 대한 유연성을 확보 할 수있다.
- 어떤 한 객체가 다른 요소들과의 연관 관계를 가질 때, 유연성을 확보 할 수있다.

## 1. Abstract Factory

## 언제 쓰냐?

- 상세화된 서브 클래스를 정의하지 않고도 서로 관련이 있거나 독립적인 여러 객체의 군을 생성하기 위한 인터페이스를 정의합니다.
- 객체가 생성되거나 구성 표현되는 방식과 무관하게 시스템을 독립적으로 만들고자 할 때
- 관련된 제품 객체들이 함께 사용되도록 설계 되었고 한번 구성한 제품을 다른 것으로 구성 하고자 할때
- 제품에 대한 클래스 라이브러리를 제공하고 그들의 구현이 아닌 인터페이스를 노출 시키고 싶을 때
- 제품의 유사군 들이 존재 할 때 유연한 설계에 중점을 둔다.

## 장/단

- 구체적인 클래스를 분리 할 수있다.
    - 생성할 객체의 클래스를 제어할 수 있다. 제품 객체를 생성하는 과정과 책임을 캡슐화 한것
- 쉽게 대체 할 수 있게 한다.
    - 구체 팩토리의 클래스는 한번만 나타내기 때문에, 응용 프로그램이 사용할 구체 팩토리를 변경하는것은 쉽다.
- 새로운 종류의 제품을 제공하기가 어렵다
    - 생성되는 제품은 추상 팩토리가 생성할 수있는 제품 집합에만 고정되어있음.

## 구현 하면서 느낀 것

- 시그니쳐가 정말 명확해야 한다.
    - **제품 군**의 인터페이스가 잘 도출된 상황에서 써야 효과적임.
    - 시그니쳐가 명확하지 않다면 상세 구현을 갈아 엎기에 큰 비용을 소모 할것같음.

## 2. Builder

- 객체를 생성하는 방법과 표현하는 방법을 분리한다.
- 서로 다른 표현이라도 생성할 수있는 동일한 절차(builder)를 제공한다.
- 복잡한 객체의 단계별 생성에 중점을 둔다.

- 복합 객체의 생성 로직 / 합성 하는 로직이 독립적 일 때
- 합성한 객체들의 표현이 서로 다르더라도 생성 절차에서 이를 지원 할때
- 제품마다 그 제품을 표현하는 방법이 달라서 공통적인 기본 클래스가 필요 없을 때

## 장/단

- 제품에 대한 내부 표현에 대해 자유로움
    - 어떤 요소에서 복합 되는지, 요소들의 표현방법이 무엇인지 가릴 수 있음
- 생성과 표현에 필요한 코드를 분리
    - 내부 구조를 정의한 클래스는 전혀 모른채, 빌더와의 상호작용들 통해 필요한 객체를 생성한다.

## 구현 하면서 느낀 것

- 복잡한 객체의 표현에 대해서 유연하게 대처 할 수 있다.
    - 객체를 정말 작은 원자 단위로 표현 해야..
    - Director를 적절한 단위로 설계하는것이 중요 할 것 같다.
    - builder의 depth가 깊어지면 알아보기 어렵게 될 듯.

## 3. Factory Method

- **객체를 생성하는 것은 별도의 연산으로 분리하여서, 이 연산을 서브 클래스에서 재정의 하게 합니다.**
- 객체를 생성하기 위해 인터페이스를 정의하지만, 어떤 클래스의 인스턴스를 생성 할지에 대한 결정은 서브클래스가 내리도록 합니다.
- 어떤 클래스가 자신이 생성해야하는 객체의 클래스를 예측할 수 없을 때
- 생성할 객체를 기술하는 책임을 자신의 서브 클래스가 지정했으면 할 때
- 객체 생성의 책임을 몇개의 보조 서브클래스 가운데 하나에게 위임하고, 어떤 서브클래스가 위임자인지에 대한 정보를 국소화 시키고 싶을 때
- 서브 클래스를 통해 실제 필요한 factory method를 정의하여 적절한 Concrete 인스턴스를 반환 할 수 있게 한다.
- 응용 프로그램에 국한된 클래스가 코드에 종속되지 않게 해준다.

    ## 구현 하면서 느낀 것

    - 여러가지 제품군을 가지고 있고, 제품 하나가 적절한 컴퍼넌트 단위로 나누어져 있는 상황이라면 꽤나 유용히 쓰일 수 있을것 같음
    - 추상화를 어떻게 하느냐에 따라 다르겠지만 서브클래스가 엄청나게 늘어날 수도 있겠음

## 4. ProtoType

- 원형이 되는 인스턴스를 사용하여 생성할 객체의 종류를 명시하고, 견본을 복사해서 새로운 객체를 생성합니다.
- 인스턴스화할 클래스를 런타임에 지정할때
- 병렬적으로 만드는 팩토리 클래스를 피하고 싶을때
- 클래스의 인스턴스들이 **서로 다른 상태의 조합 중에 어느 하나일 때**
- 값/구조들을 다양화 함으로써 새로운 객체를 명세합니다.
    - 서브클래스의 수를 줄 일 수 있다.
- 구조가 복잡한 prototype을 복제 할 때는 deep copy가 필요하다.
- 초기화 연산을 구현 해 주어야 한다.
    - 내부의 상태를 자신이 선택한 값으로 초기화 하기를 원할 수도 있음. 그러나 각 prototype마다 필요한 매개변수의 개수가 다르기 때문에 clone()연산의 일관성이 없어진다.

## 구현 하면서 느낀 것
- ? builder랑 비슷한 느낌이다..
- 클래스의 수를 많이 늘리지 않아도 확장이 쉬운 부분이 좋다.
- 만들고자 하는 객체가 서로 다른 상태의 조합중에 하나일때 유용할것.
