# 디자인 패턴 스터디
## 생성 패턴
객체를 생성할 때 마다 생성자를 하나하나 하드코딩하면 좋지 못하다. 유연하지 못하기 때문이다. 책에서는 미로를 만드는 코드로 생성 패턴을 설명해나가고 있는데, 미로에 방을 하나 추가하고 싶으면 똑같은 로직을 복사-붙여넣기 해야 하니 코드 중복이 생기게 된다. 여기까지만 해도 충분히 안티패턴인데, 만약 내가 방의 레이아웃을 바꾸기라도 해야 한다면... 전체를 새로 다시 작성해야 하거나 함수의 중간을 뜯어고치게 된다. 이렇게 하나를 고쳐야 한다고 전체를 뜯어고치는 구조는 재사용성이 0점이다.
책에서는 이런 문제점을 해결하기 위해 클래스의 인스턴스를 직접 생성하지 않고 다양한 방법으로 위임하는 패턴들을 소개하고 있다.

1. 추상 팩토리 패턴
2. 팩토리 메서드 패턴
3. 빌더 패턴

### 추상 팩토리 패턴
제품의 종류가 여러가지 있을 때 유용한 패턴이다. 예를 들어서, 내가 UI툴킷을 사용한다고 해보자. PMWindow 툴킷과 MotifWindow 툴킷을 바꿔 끼워서 사용이 가능하다면 이식성이 좋고 유연할 것이다. 그렇다면 우선 추상화된 팩토리 WidgetFactory에서 윈도우와 스크롤바를 만드는 메소드를 인터페이스로 추상화한다. 추상화된 제품인 Window와 Scrollbar를 반환하게 된다. 구체화 팩토리 클래스 MotifWidgetFactory와 PMWidgetFactory를 준비한다. 그리고 추상 팩토리의 윈도우와 스크롤바를 만드는 메소드를 구현하게 된다. 각각의 팩토리 메소드에서는 추상 제품을 구체화한 PMWindow, MotifWindow, PMScrollbar,MotifScrollbar를 반환한다.
이러면 내가 어떤 UI툴킷을 사용하는지 사용측에서는 알 필요가 없다. 전부 동일한 동작을 보장하기 때문이다. 그리고 동일한 제약이 어느 곳에나 적용되기 때문이다. 그렇지만 단점이 있는데, 인터페이스에서 이미 정의하지 않은 새로운 제품을 만들어내기 힘들다. 만약 내가 새로운 제품을 추가한다면 인터페이스를 수정하고 그것을 구현한 모든 구현체가 전부 수정되어야 할 것이다. 만약 내가 제품의 반환 타입이 변경됐다면 역시 그것을 구현한 구현체를 하나하나 수정하고 검증해야 할 것이다.

### 빌더 패턴
객체의 생성과 표현을 분리해내는 패턴이다. 만약 내가 다양한 포맷을 지원하는 문서 판독기를 만들어야 할 때 추상화하기 좋은 패턴이다. 문서를 판독하는 과정은 빌더 패턴의 특징인 순차적으로 프로덕트를 만들어낸 후 최종 결과를 반환하는 과정과 일맥상통하기 때문이다. 디렉터와 구체화된 디렉터로 구성된다. 우선 사용처에서는 디렉터를 부르게 되는데, 이 때 어떤 구체 디렉터를 택하는 상관이 없다. 그리고 구축을 하면, 디렉터에서 우리가 사용하고자 하는 구체 디렉터에서 buildA, buildB, buildC 처럼 순차적으로 제품을 조립해나간다. 그리고 난 뒤 최종 결과를 받아내면 끝이다.

### 팩토리 메서드
추상 팩토리 패턴과 비슷하다. 추상 팩토리 패턴과 다른 점은 팩토리가 추상화되어 있지 않고 메소드라는 점이다. 추상화는 팩토리 자체 레벨이 아닌 팩토리를 사용하는 레벨에서 진행하게 된다. 그리고 각각의 추상화된... 팩토리가 필요한 레벨은 각각의 팩토리 메서드를 갖는다. 만약 내가 문서를 읽는 프로그램을 만든다고 했을 때, 그림을 읽을 수도 있고 텍스트를 읽을수도 있을 것이다. 이럴 때, 그림을 읽는 쪽에서는 문서를 만드는 factory 메서드를 가지고 텍스트를 읽는 쪽에서도 문서를 만드는 factory 메소드를 갖고 각각 Product를 생성해내게 된다.  이렇게 되면, 파일을 여는 다이얼로그를 각각 재정의할 수도 있게 된다. 이것을 책에서는 서브클래스에 대한 hook을 제공해준다고 표현되어 있다. 또 장점이 팩토리 메서드를 매개변수화 할 수 있다고 한다. 하나의 팩토리 메소드가 여러 종류의 제품을 생산할 수 있다고 하는데 개인적으로 읽으면서 이건 SRP(Single Responsibility Principal) 위반이 아닌가 생각이 들었다.
